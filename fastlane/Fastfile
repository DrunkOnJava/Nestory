# Fastfile ‚Äî modernized for CI and current fastlane best practices

default_platform(:ios)

# ---- Shared config via ENV (override with `.env` or lane options) ----
APP_IDENTIFIER   = ENV['APP_IDENTIFIER']   || 'com.nestory.app'
SCHEME           = ENV['SCHEME']           || 'Nestory-Dev'
WORKSPACE        = ENV['WORKSPACE']        || nil        # e.g., 'Nestory.xcworkspace' (nil -> use project)
PROJECT          = ENV['PROJECT']          || 'Nestory.xcodeproj'
ASSETS_PATH      = ENV['ASSETS_PATH']      || 'App-Main/Assets.xcassets'
ICONSET_NAME     = ENV['ICONSET_NAME']     || 'AppIcon'
CONFIGURATION    = ENV['CONFIGURATION']    || 'Release'
OUTPUT_DIR       = ENV['OUTPUT_DIR']       || 'fastlane/output'
TEAM_ID          = ENV['TEAM_ID']          || ''         # optional
XCODE_VERSION    = ENV['XCODE_VERSION']    || nil        # e.g., '16.0' to pin

# ASC API key: prefer environment or a local json path; never commit secrets
ASC_KEY_ID       = ENV['ASC_KEY_ID']
ASC_ISSUER_ID    = ENV['ASC_ISSUER_ID']
ASC_KEY_CONTENT  = ENV['ASC_KEY_CONTENT']  # Base64 or raw p8 content (preferred)
# OR ASC_KEY_PATH = 'fastlane/AuthKey_XXXXXXXXXX.p8'

# App Store Connect API Configuration
ASC_API_ENABLED  = ENV['ASC_API_ENABLED'] == 'true'
ASC_BUNDLE_ID    = ENV['ASC_BUNDLE_ID'] || 'com.nestory.app.dev'

platform :ios do
  # ------------------------------
  # Global CI initialization hooks
  # ------------------------------
  before_all do
    setup_ci if ENV['CI']                         # sets locale/timezone and xcodebuild env for CI
    ensure_xcode_version(version: XCODE_VERSION) if XCODE_VERSION
    create_keychain(name: "fastlane_tmp", default_keychain: true, unlock: true, timeout: 3600, lock_when_sleeps: false) if is_ci
    sh("mkdir -p #{OUTPUT_DIR}")
  end

  after_all do
    UI.success("‚úÖ All lanes finished successfully.")
  end

  error do |lane, exception|
    UI.error("‚ùå Lane '#{lane}' failed: #{exception.message}")
    UI.message("See logs under #{OUTPUT_DIR}")
  end

  # ------------------------------
  # Code quality & tests
  # ------------------------------
  desc "Run unit/UI tests with scan"
  lane :tests do |opts|
    scan(
      scheme: opts[:scheme] || SCHEME,
      project: WORKSPACE ? nil : PROJECT,
      workspace: WORKSPACE,
      clean: true,
      derived_data_path: "#{OUTPUT_DIR}/DerivedData",
      output_directory: "#{OUTPUT_DIR}/tests",
      buildlog_path: "#{OUTPUT_DIR}/logs/tests",
      result_bundle: true,
      fail_build: true
    )
  end

  # ------------------------------
  # Build
  # ------------------------------
  desc "Build archive for distribution"
  lane :build do |opts|
    ensure_git_status_clean unless is_ci # optional; skip in CI
    version_bump = opts[:bump_build] || false
    increment_build_number if version_bump

    build_app(
      scheme: opts[:scheme] || SCHEME,
      project: WORKSPACE ? nil : PROJECT,
      workspace: WORKSPACE,
      configuration: CONFIGURATION,
      clean: true,
      output_directory: "#{OUTPUT_DIR}/build",
      output_name: "#{SCHEME}.ipa",
      include_bitcode: false,                   # modern: false
      include_symbols: true,                    # produce dSYM
      export_method: "app-store",
      export_options: {
        provisioningProfiles: {
          APP_IDENTIFIER => opts[:provisioning_profile] || ""
        },
        uploadSymbols: true,
        compileBitcode: false
      },
      buildlog_path: "#{OUTPUT_DIR}/logs/build",
      # Ensure dSYM generation and allow provisioning updates
      xcargs: "-allowProvisioningUpdates DEBUG_INFORMATION_FORMAT=dwarf-with-dsym ENABLE_BITCODE=NO"
    )
  end

  # ------------------------------
  # TestFlight
  # ------------------------------
  private_lane :asc_api_key do
    # Prefer key content via ENV; fallback to a file path
    if ASC_KEY_CONTENT && ASC_KEY_ID && ASC_ISSUER_ID
      app_store_connect_api_key(
        key_id: ASC_KEY_ID,
        issuer_id: ASC_ISSUER_ID,
        key_content: ASC_KEY_CONTENT,
        is_key_content_base64: ASC_KEY_CONTENT.start_with?("MII"), # best-effort; tweak as needed
        duration: 1200,
        in_house: false
      )
    elsif ENV['ASC_KEY_PATH'] && ASC_KEY_ID && ASC_ISSUER_ID
      app_store_connect_api_key(
        key_id: ASC_KEY_ID,
        issuer_id: ASC_ISSUER_ID,
        key_filepath: ENV['ASC_KEY_PATH'],
        duration: 1200,
        in_house: false
      )
    else
      UI.message("App Store Connect API key not configured. Will use interactive auth if needed.")
    end
  end

  desc "Build and upload to TestFlight"
  lane :beta do |opts|
    # Optional: run tests before betas
    tests(scheme: opts[:scheme]) unless opts[:skip_tests]

    # Build
    build(opts)

    # Authenticate
    asc_api_key

    # Changelog from git commits
    notes = changelog_from_git_commits(
      commits_count: 50,
      merge_commit_filtering: "exclude_merges"
    ) rescue "Bug fixes and improvements"

    upload_to_testflight(
      app_identifier: APP_IDENTIFIER,
      skip_waiting_for_build_processing: true,
      changelog: notes,
      distribute_external: !!opts[:external],   # set true to auto-start external testing
      groups: opts[:groups] || [],              # e.g. ["Internal"]
      beta_app_review_info: {
        contact_email: ENV['BETA_CONTACT_EMAIL'],
        contact_first_name: ENV['BETA_CONTACT_FIRST_NAME'],
        contact_last_name: ENV['BETA_CONTACT_LAST_NAME'],
        contact_phone: ENV['BETA_CONTACT_PHONE'],
        demo_account_name: ENV['BETA_DEMO_USER'],
        demo_account_password: ENV['BETA_DEMO_PASS']
      }
    )
  end

  # ------------------------------
  # App Store release
  # ------------------------------
  desc "Submit to App Store (metadata + binary)"
  lane :release do |opts|
    asc_api_key

    precheck(  # validates metadata, age ratings, etc.
      app_identifier: APP_IDENTIFIER,
      default_rule_level: "warn"
    )

    # Upload binary & metadata/screenshots if you keep them under fastlane/metadata
    deliver(
      app_identifier: APP_IDENTIFIER,
      submit_for_review: !!opts[:submit],
      automatic_release: !!opts[:auto_release],
      force: true,
      skip_screenshots: opts[:skip_screenshots] || true,
      skip_metadata: opts[:skip_metadata] || false,
      skip_binary_upload: false
    )
  end

  # ------------------------------
  # Screenshots (snapshot)
  # ------------------------------
  desc "Capture localized screenshots"
  lane :screenshots do |opts|
    # Prefer Snapfile for devices/locales; keep here if you want a single-lane config
    capture_screenshots(
      project: WORKSPACE ? nil : PROJECT,
      workspace: WORKSPACE,
      scheme: opts[:scheme] || SCHEME,
      clear_previous_screenshots: true,
      reinstall_app: true,
      languages: opts[:languages] || ["en-US"],
      devices: opts[:devices] || [
        "iPhone 16 Pro Max",
        "iPhone 16 Pro",
        "iPad Pro (12.9-inch) (6th generation)"
      ],
      output_directory: "#{OUTPUT_DIR}/screenshots",
      buildlog_path: "#{OUTPUT_DIR}/logs/snapshot"
    )
  end

  desc "Open screenshots in Finder"
  lane :open_screenshots do
    sh "open #{OUTPUT_DIR}/screenshots/"
  end

  desc "Clear all screenshot data"
  lane :clear_screenshots do
    clear_derived_data
    sh "rm -rf #{OUTPUT_DIR}/screenshots/*"
    UI.success "Cleared all screenshot data"
  end

  # ------------------------------
  # Validation fixes
  # ------------------------------
  desc "Fix all validation issues for App Store submission"
  lane :fix_validation do
    UI.message "üîß Fixing validation issues..."
    
    # Ensure dSYM generation is enabled via xcargs in build
    UI.message "üìù dSYM generation will be enforced during build"
    UI.message "Build settings to use:"
    UI.message "  - DEBUG_INFORMATION_FORMAT = dwarf-with-dsym"
    UI.message "  - ENABLE_BITCODE = NO"
    
    # Clean derived data
    clear_derived_data
    
    UI.success "‚úÖ Derived data cleared"
    UI.success "‚úÖ All validation fixes applied!"
    UI.message ""
    UI.message "Next steps:"
    UI.message "1. Run: bundle exec fastlane build"
    UI.message "2. Or archive in Xcode with proper settings"
  end

  # ------------------------------
  # App icons (fastlane-plugin-appicon)
  # ------------------------------
  desc "Generate full iOS AppIcon set from a source PNG"
  lane :icons do |opts|
    # Check common locations for icon if not provided
    source = opts[:source] || ENV['ICON_SOURCE']
    
    if source.nil?
      possible_paths = [
        "assets/icon.png",
        "AppIcon.png",
        "icon.png",
        "/Users/griffin/Pictures/nestoryappicon2.png"
      ]
      
      source = possible_paths.find { |path| File.exist?(path) }
      
      if source.nil?
        UI.user_error!("No icon file found. Please provide source:path/to/icon.png or set ICON_SOURCE env var")
      end
    end
    
    UI.user_error!("Icon source not found: #{source}") unless File.exist?(source)

    UI.message "üé® Generating iOS app icons from: #{source}"
    
    appicon(
      appicon_image_file: source,
      appicon_path: ASSETS_PATH,
      appicon_name: ICONSET_NAME,                         # ‚úÖ correct key
      appicon_devices: [:iphone, :ipad, :ios_marketing],
      remove_alpha: false
    )

    UI.success "‚úÖ Icons generated at #{ASSETS_PATH}/#{ICONSET_NAME}.appiconset"
  end

  # ------------------------------
  # App Store Connect API Integration
  # ------------------------------
  desc "Configure app metadata via App Store Connect API"
  lane :configure_app_metadata do |opts|
    ensure_asc_api_key
    
    UI.message "üì± Configuring app metadata for #{ASC_BUNDLE_ID}..."
    
    # Configure app categories
    categories = opts[:categories] || {
      primary: "PRODUCTIVITY",
      secondary: "UTILITIES"
    }
    
    # Configure app localizations
    localizations = opts[:localizations] || [
      {
        locale: "en-US",
        name: "Nestory",
        subtitle: "Home Inventory for Insurance",
        description: load_app_description,
        keywords: "home inventory, insurance, documentation, receipt scanner, warranty tracker",
        promotional_text: "Protect your belongings with comprehensive insurance documentation",
        support_url: "https://nestory.app/support",
        marketing_url: "https://nestory.app",
        privacy_policy_url: "https://nestory.app/privacy"
      }
    ]
    
    # Configure age rating
    age_rating = opts[:age_rating] || {
      alcohol_tobacco_drug: "NONE",
      gambling: "NONE",
      horror_fear: "NONE",
      mature_content: "NONE",
      medical: "NONE",
      profanity: "NONE",
      sexual_content: "NONE",
      violence_cartoon: "NONE",
      violence_realistic: "NONE"
    }
    
    # Execute via Ruby script that uses our Swift API client
    sh("ruby #{File.expand_path('../scripts/configure_metadata.rb', __dir__)} " \
       "--bundle-id #{ASC_BUNDLE_ID} " \
       "--primary-category #{categories[:primary]} " \
       "--secondary-category #{categories[:secondary]} " \
       "--age-rating '#{age_rating.to_json}'")
    
    UI.success "‚úÖ App metadata configured successfully"
  end

  desc "Create new app version"
  lane :create_app_version do |opts|
    ensure_asc_api_key
    
    version = opts[:version] || get_version_number
    platform = opts[:platform] || "IOS"
    
    UI.message "üì¶ Creating app version #{version}..."
    
    sh("ruby #{File.expand_path('../scripts/create_version.rb', __dir__)} " \
       "--bundle-id #{ASC_BUNDLE_ID} " \
       "--version #{version} " \
       "--platform #{platform}")
    
    UI.success "‚úÖ Version #{version} created"
  end

  desc "Upload screenshots via API"
  lane :upload_screenshots_api do |opts|
    ensure_asc_api_key
    
    version = opts[:version] || get_version_number
    screenshots_path = opts[:path] || "#{OUTPUT_DIR}/screenshots"
    
    UI.message "üì∏ Uploading screenshots for version #{version}..."
    
    # Validate screenshots exist
    UI.user_error!("Screenshots not found at #{screenshots_path}") unless Dir.exist?(screenshots_path)
    
    sh("ruby #{File.expand_path('../scripts/upload_screenshots.rb', __dir__)} " \
       "--bundle-id #{ASC_BUNDLE_ID} " \
       "--version #{version} " \
       "--screenshots-path #{screenshots_path}")
    
    UI.success "‚úÖ Screenshots uploaded successfully"
  end

  desc "Submit version for review"
  lane :submit_for_review do |opts|
    ensure_asc_api_key
    
    version = opts[:version] || get_version_number
    build_number = opts[:build] || get_build_number
    
    # Review information
    review_info = {
      demo_required: opts[:demo_required] || false,
      demo_account: opts[:demo_account],
      demo_password: opts[:demo_password],
      notes: opts[:notes] || "No special instructions",
      contact_first_name: opts[:first_name] || ENV['ASC_CONTACT_FIRST_NAME'],
      contact_last_name: opts[:last_name] || ENV['ASC_CONTACT_LAST_NAME'],
      contact_email: opts[:email] || ENV['ASC_CONTACT_EMAIL'],
      contact_phone: opts[:phone] || ENV['ASC_CONTACT_PHONE']
    }
    
    UI.message "üì§ Submitting version #{version} (#{build_number}) for review..."
    
    sh("ruby #{File.expand_path('../scripts/submit_review.rb', __dir__)} " \
       "--bundle-id #{ASC_BUNDLE_ID} " \
       "--version #{version} " \
       "--build #{build_number} " \
       "--review-info '#{review_info.to_json}'")
    
    UI.success "‚úÖ Version submitted for review"
  end

  desc "Set phased release for version"
  lane :configure_phased_release do |opts|
    ensure_asc_api_key
    
    version = opts[:version] || get_version_number
    release_type = opts[:release_type] || "AFTER_APPROVAL" # MANUAL, AFTER_APPROVAL, SCHEDULED
    release_date = opts[:release_date] # For SCHEDULED releases
    
    UI.message "‚è∞ Configuring release type for version #{version}..."
    
    sh("ruby #{File.expand_path('../scripts/configure_release.rb', __dir__)} " \
       "--bundle-id #{ASC_BUNDLE_ID} " \
       "--version #{version} " \
       "--release-type #{release_type} " \
       "#{'--release-date ' + release_date if release_date}")
    
    UI.success "‚úÖ Release configuration updated"
  end

  desc "Submit export compliance declaration"
  lane :submit_export_compliance do |opts|
    UI.message "üìã Submitting export compliance declaration..."
    
    # Nestory uses only exempt encryption (HTTPS, iOS crypto)
    # No export license or annual reporting required
    
    build_number = opts[:build] || get_build_number
    
    UI.message "‚úÖ Export compliance configured:"
    UI.message "  ‚Ä¢ Uses only exempt encryption (HTTPS, iOS Data Protection)"
    UI.message "  ‚Ä¢ No proprietary cryptography"
    UI.message "  ‚Ä¢ No export license required"
    UI.message "  ‚Ä¢ No annual reporting required"
    UI.message "  ‚Ä¢ ITSAppUsesNonExemptEncryption = false"
    
    UI.success "‚úÖ Export compliance declaration complete"
  end

  desc "Complete App Store submission workflow"
  lane :complete_submission do |opts|
    # Build and upload
    build
    beta
    
    # Configure metadata
    configure_app_metadata(opts)
    
    # Create version if needed
    create_app_version(opts)
    
    # Submit export compliance
    submit_export_compliance(opts)
    
    # Upload screenshots
    if opts[:skip_screenshots] != true
      screenshots
      upload_screenshots_api(opts)
    end
    
    # Submit for review
    submit_for_review(opts)
    
    # Configure release
    configure_phased_release(opts)
    
    UI.success "üéâ Complete submission workflow finished!"
  end

  # ------------------------------
  # Helper methods
  # ------------------------------
  private_lane :ensure_asc_api_key do
    if ASC_KEY_ID.nil? || ASC_ISSUER_ID.nil? || ASC_KEY_CONTENT.nil?
      UI.user_error!("App Store Connect API credentials not configured. Set ASC_KEY_ID, ASC_ISSUER_ID, and ASC_KEY_CONTENT")
    end
  end

  private_lane :load_app_description do
    description_file = "fastlane/metadata/en-US/description.txt"
    if File.exist?(description_file)
      File.read(description_file)
    else
      "Nestory is your comprehensive home inventory solution designed specifically for insurance documentation. " \
      "Catalog your belongings with photos, receipts, and warranties to protect yourself against disasters. " \
      "Features include receipt OCR scanning, insurance report generation, and secure cloud backup."
    end
  end
end