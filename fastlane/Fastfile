# Minimal Fastfile for JWT testing
# UTF-8 bulletproofing
ENV['LANG']  ||= 'en_US.UTF-8'
ENV['LC_ALL'] ||= 'en_US.UTF-8'

# Load environment variables
require 'dotenv'
env_path = File.expand_path('../.env', __dir__)
Dotenv.load(env_path) if File.exist?(env_path)

default_platform(:ios)

# Constants
ASC_BUNDLE_ID = ENV['ASC_BUNDLE_ID'] || 'com.nestory.app.dev'

# Retry helper
def with_retry(max: 3, base_delay: 2)
  attempts = 0
  begin
    attempts += 1
    return yield
  rescue Spaceship::UnexpectedResponse, Faraday::TimeoutError, Faraday::ConnectionFailed => e
    raise if attempts >= max
    delay = base_delay * attempts
    UI.message("â³ Attempt #{attempts} failed, retrying in #{delay}s...")
    sleep delay
    retry
  end
end

# Process cleanup helper to prevent runaway Ruby processes
def cleanup_hung_processes
  UI.message("ğŸ§¹ Cleaning up any hung processes...")
  
  # Kill any stuck ruby/fastlane processes (except this one)
  current_pid = Process.pid
  begin
    hung_processes = `ps aux | grep -E "(ruby.*fastlane|xcodebuild)" | grep -v grep | grep -v #{current_pid}`.strip.split("\n")
    
    hung_processes.each do |process_line|
      if match = process_line.match(/^\S+\s+(\d+)/)
        pid = match[1].to_i
        next if pid == current_pid
        
        UI.message("  Killing hung process: PID #{pid}")
        begin
          Process.kill("TERM", pid)
          sleep 2
          # Send SIGKILL if still running
          Process.kill("KILL", pid) if process_running?(pid)
        rescue Errno::ESRCH
          # Process already dead
        rescue => e
          UI.warning("  Failed to kill PID #{pid}: #{e.message}")
        end
      end
    end
  rescue => e
    UI.warning("Failed to clean up hung processes: #{e.message}")
  end
  
  # Clean up any leftover fastlane PID files
  Dir.glob("/tmp/fastlane_*.pid").each do |pid_file|
    File.delete(pid_file) rescue nil
  end
end

# Check if process is still running
def process_running?(pid)
  begin
    Process.kill(0, pid)
    true
  rescue Errno::ESRCH
    false
  end
end

platform :ios do
  # JWT API key setup
  def asc_api_key
    if !ENV["ASC_KEY_CONTENT"].to_s.strip.empty?
      # Use inline key content (base64 decoded)
      require 'base64'
      key_content = Base64.decode64(ENV["ASC_KEY_CONTENT"])
      app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_content: key_content,
        duration: 1200,
        in_house: false
      )
    elsif ENV["ASC_KEY_PATH"]
      # Use key file path (handle relative paths)
      key_path = ENV["ASC_KEY_PATH"]
      if !key_path.start_with?('/')
        key_path = File.expand_path("../#{key_path}", __dir__)
      end
      
      app_store_connect_api_key(
        key_id: ENV["ASC_KEY_ID"],
        issuer_id: ENV["ASC_ISSUER_ID"],
        key_filepath: key_path,
        duration: 1200,
        in_house: false
      )
    else
      UI.user_error!("No valid ASC_KEY_CONTENT or ASC_KEY_PATH found in environment")
    end
  end

  private_lane :ensure_asc_api_key do
    required_keys = ['ASC_KEY_ID', 'ASC_ISSUER_ID']
    missing = required_keys.select { |key| ENV[key].nil? || ENV[key].strip.empty? }
    
    if missing.any?
      UI.user_error!("Missing required ASC environment variables: #{missing.join(', ')}")
    end
    
    # Handle relative paths for ASC_KEY_PATH
    key_path = ENV["ASC_KEY_PATH"]
    if key_path && !key_path.start_with?('/')
      key_path = File.expand_path("../#{key_path}", __dir__)
    end
    
    unless ENV["ASC_KEY_CONTENT"] || (key_path && File.exist?(key_path))
      UI.user_error!("Must provide either ASC_KEY_CONTENT or ASC_KEY_PATH (#{key_path})")
    end
  end

  private_lane :asc_api_login! do
    asc_api_key
    require 'spaceship'
    Spaceship::ConnectAPI.token
  end

  desc "Create app in App Store Connect via API"
  lane :create_app_asc do |opts|
    ensure_asc_api_key
    asc_api_login!
    
    bundle_id = ENV['ASC_BUNDLE_ID'] || ASC_BUNDLE_ID
    app_name = opts[:name] || "Nestory Dev"
    sku = opts[:sku] || "nestory-dev-#{Time.now.to_i}"
    
    UI.message "ğŸš€ Creating app in App Store Connect..."
    UI.message "ğŸ“± Bundle ID: #{bundle_id}"
    UI.message "ğŸ“ App Name: #{app_name}"
    UI.message "ğŸ”‘ Using JWT authentication (no 2FA required)"
    
    begin
      # Use produce action to create the app (handles JWT automatically)
      produce(
        app_name: app_name,
        language: "en-US",
        app_identifier: bundle_id,
        sku: sku,
        platform: "ios",
        skip_itc: false,
        skip_devcenter: true,  # Skip Developer Center, only create in App Store Connect
        username: ENV['APPLE_ID'] || "griffinradcliffe@gmail.com"  # Needed even with JWT
      )
      
      UI.success("âœ… Successfully created app: #{app_name}")
      UI.message("ğŸ“¦ Bundle ID: #{bundle_id}")
      UI.message("ğŸ”— SKU: #{sku}")
      
    rescue => e
      UI.error("âŒ Failed to create app: #{e.message}")
      UI.message("ğŸ“‹ This might be because:")
      UI.message("   â€¢ Bundle ID already exists")
      UI.message("   â€¢ Insufficient API permissions") 
      UI.message("   â€¢ App name conflicts")
      
      # If it fails due to existing app, that's actually success
      if e.message.include?("already exists") || e.message.include?("already taken")
        UI.success("âœ… App already exists - that's fine!")
        return
      end
      
      raise e
    end
  end

  desc "List all apps in App Store Connect"
  lane :list_apps_asc do |opts|
    ensure_asc_api_key
    asc_api_login!
    
    UI.message "ğŸ” Listing all apps in App Store Connect..."
    
    apps = with_retry { Spaceship::ConnectAPI::App.all }
    
    if apps.empty?
      UI.message("ğŸ“­ No apps found in App Store Connect")
    else
      UI.success("ğŸ“± Found #{apps.count} app(s):")
      apps.each do |app|
        UI.message("  â€¢ #{app.name} (#{app.bundle_id}) - ID: #{app.id}")
      end
    end
  end

  desc "Verify JWT access to App Store Connect"
  lane :asc_verify_app do |opts|
    ensure_asc_api_key
    asc_api_login!
    
    bundle_id = ENV['ASC_BUNDLE_ID'] || ASC_BUNDLE_ID
    UI.message "ğŸ” Verifying App Store Connect access for #{bundle_id}..."
    
    app = with_retry { Spaceship::ConnectAPI::App.find(bundle_id) }
    
    if app
      UI.success("âœ… JWT auth OK - Found app: #{app.name} (#{bundle_id})")
      UI.message("ğŸ“± Platform: iOS")
      UI.message("ğŸ†” App ID: #{app.id}")
    else
      UI.error("âŒ App not found: #{bundle_id}")
      UI.message("Create the app manually in App Store Connect first")
    end
  end

  desc "Upload existing archive to TestFlight using JWT"
  lane :upload_existing_archive do |opts|
    ensure_asc_api_key
    asc_api_login!
    
    # Find the most recent archive
    archive_path = Dir.glob("#{ENV['HOME']}/Library/Developer/Xcode/Archives/**/*.xcarchive").max_by { |f| File.mtime(f) }
    unless archive_path
      UI.user_error!("No archive found. Create an archive in Xcode first.")
    end
    
    UI.message "ğŸš€ Uploading existing archive to TestFlight..."
    UI.message "ğŸ“¦ Archive: #{File.basename(archive_path)}"
    UI.message "ğŸ”‘ Using JWT authentication (no 2FA required)"
    
    # Extract IPA from archive for upload
    ipa_path = "/tmp/Nestory.ipa"
    
    # Export IPA from archive using xcodebuild
    UI.message "ğŸ“¤ Exporting IPA from archive..."
    sh("xcodebuild -exportArchive -archivePath '#{archive_path}' -exportPath '/tmp' -exportOptionsPlist /dev/stdin <<< '<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">
<plist version=\"1.0\">
<dict>
    <key>method</key>
    <string>app-store</string>
    <key>uploadBitcode</key>
    <false/>
    <key>uploadSymbols</key>
    <true/>
</dict>
</plist>'")
    
    # Upload to TestFlight
    upload_to_testflight(
      ipa: ipa_path,
      app_identifier: ENV['ASC_BUNDLE_ID'] || 'com.nestory.app.dev',
      skip_waiting_for_build_processing: false,
      skip_submission: false,
      distribute_external: false,
      notify_external_testers: false,
      changelog: "Automated upload via JWT pipeline"
    )
    
    UI.success("âœ… Archive uploaded to TestFlight successfully!")
    
    # Cleanup
    File.delete(ipa_path) if File.exist?(ipa_path)
  end

  desc "Ensure an App Store version exists (idempotent)"
  lane :ensure_app_version do |opts|
    ensure_asc_api_key
    asc_api_login!
    
    bundle_id = ENV['ASC_BUNDLE_ID'] || ASC_BUNDLE_ID
    version   = (opts[:version] || "1.0.1").to_s
    platform  = Spaceship::ConnectAPI::Platform::IOS

    UI.message "ğŸ“¦ Ensuring App Store version #{version} exists for #{bundle_id}..."
    UI.message "ğŸ”‘ Using JWT authentication (no 2FA required)"

    app = with_retry { Spaceship::ConnectAPI::App.find(bundle_id) }
    
    unless app
      UI.user_error!("App not found on App Store Connect: #{bundle_id}")
    end

    # Check if version already exists (idempotent)
    existing = with_retry do
      app.get_app_store_versions(
        filter: { platform: platform, versionString: version },
        limit: 2
      ).first
    end
    
    if existing
      UI.success("âœ… App Store version #{version} already exists (#{existing.app_store_state})")
    else
      # Create new version
      begin
        created = Spaceship::ConnectAPI::AppStoreVersion.create(
          app_id: app.id,
          version_string: version,
          platform: platform
        )
        UI.success("âœ… Created App Store version #{version} â€” id=#{created.id}")
      rescue NoMethodError => e
        if e.message.include?("create")
          UI.message "ğŸ”„ Using fallback signature for AppStoreVersion creation"
          created = app.create_app_store_version(version_string: version, platform: platform)
          UI.success("âœ… Created App Store version #{version} (fallback) â€” id=#{created.id}")
        else
          raise e
        end
      end
    end
  end

  # =========================================================================
  # SCREENSHOT AUTOMATION
  # =========================================================================

  desc "Capture app screenshots for App Store Connect"
  lane :screenshots do |opts|
    UI.header "ğŸ“¸ Capturing App Store Screenshots"
    
    # Use snapshot action for screenshot capture
    snapshot(
      devices: opts[:devices] || ["iPhone 16 Pro Max", "iPhone 16 Pro", "iPad Pro (13-inch) (M4)"],
      languages: opts[:languages] || ["en-US"],
      scheme: "Nestory-Dev",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: opts[:clear] || true,
      reinstall_app: opts[:reinstall] || true,
      stop_after_first_error: false,
      test_without_building: opts[:skip_build] || false,
      concurrent_simulators: false,
      launch_arguments: [
        "-UITestMode YES",
        "-SeedDataForScreenshots YES",
        "-DisableAnimations YES"
      ]
    )
    
    UI.success("âœ… Screenshots captured successfully!")
    UI.message("ğŸ“ Screenshots saved to: ./fastlane/screenshots")
  end

  desc "Quick screenshot capture for development"
  lane :screenshots_quick do |opts|
    UI.header "ğŸ“¸ Quick Screenshot Capture"
    
    # Single device for faster development workflow
    snapshot(
      devices: ["iPhone 16 Pro Max"],
      languages: ["en-US"],
      scheme: "Nestory-Dev",
      output_directory: "./fastlane/screenshots_dev",
      clear_previous_screenshots: true,
      reinstall_app: false,
      stop_after_first_error: true,
      test_without_building: opts[:skip_build] || false,
      concurrent_simulators: false,
      launch_arguments: [
        "-UITestMode YES",
        "-SeedDataForScreenshots YES",
        "-DisableAnimations YES"
      ]
    )
    
    UI.success("âœ… Quick screenshots captured!")
  end

  desc "CI-optimized screenshot capture"
  lane :screenshots_ci do |opts|
    UI.header "ğŸ¤– CI Screenshot Capture"
    
    # Minimal device set for CI
    snapshot(
      devices: opts[:devices] || ["iPhone 16 Pro Max"],
      languages: ["en-US"],
      scheme: "Nestory-Dev",
      output_directory: "./fastlane/screenshots",
      clear_previous_screenshots: true,
      reinstall_app: false,
      stop_after_first_error: true,
      test_without_building: true,
      concurrent_simulators: false,
      launch_arguments: [
        "-UITestMode YES",
        "-SeedDataForScreenshots YES",
        "-DisableAnimations YES"
      ]
    )
    
    # Archive for CI artifacts
    sh "cd fastlane && tar -czf screenshots.tar.gz screenshots"
    UI.success("âœ… CI screenshots captured and archived!")
  end

  desc "Upload screenshots to App Store Connect"
  lane :upload_screenshots do |opts|
    ensure_asc_api_key
    asc_api_login!
    
    UI.header "ğŸ“¤ Uploading Screenshots to App Store Connect"
    
    deliver(
      skip_binary_upload: true,
      skip_metadata: true,
      screenshots_path: opts[:path] || "./fastlane/screenshots",
      force: opts[:force] || false,
      overwrite_screenshots: opts[:overwrite] || true,
      app_identifier: ENV['ASC_BUNDLE_ID'] || ASC_BUNDLE_ID
    )
    
    UI.success("âœ… Screenshots uploaded to App Store Connect!")
  end

  desc "Complete screenshot workflow: capture and upload"
  lane :screenshots_complete do |opts|
    UI.header "ğŸ“¸ Complete Screenshot Workflow"
    
    # Capture screenshots
    screenshots(opts)
    
    # Upload to App Store Connect
    if opts[:upload] != false
      upload_screenshots(
        path: "./fastlane/screenshots",
        overwrite: true
      )
    end
    
    UI.success("âœ… Complete screenshot workflow finished!")
  end

  # =========================
  # TESTING SUITE â€“ MISSING LANES
  # =========================

  desc "ğŸ§ª All Tests (Unit + UI)"
  lane :tests do
    UI.header "ğŸ§ª All Tests"
    
    # Create PID file for tracking this fastlane process
    pid_file = "/tmp/fastlane_tests_#{Process.pid}.pid"
    File.write(pid_file, Process.pid)
    
    begin
      # Use timeout to prevent hanging processes
      UI.message("ğŸ• Running tests with 10 minute timeout protection...")
      sh("cd #{Dir.pwd}/.. && timeout 600 make test || exit $?")
      sh("cd #{Dir.pwd}/.. && timeout 300 make test-wiring || exit $?")
      UI.success("âœ… All tests completed successfully!")
    rescue => e
      UI.error("âŒ Tests failed or timed out: #{e.message}")
      
      # Kill any hung processes related to this test run
      cleanup_hung_processes
      raise e
    ensure
      # Clean up PID file
      File.delete(pid_file) if File.exist?(pid_file)
    end
  end

  desc "ğŸ“Š Test Coverage Report"
  lane :coverage_validation do
    UI.header "ğŸ“Š Coverage Validation"
    # Prefer your Makefile if it emits coverage artifacts:
    # sh("cd #{Dir.pwd} && make coverage")
    # Or run with scan and gather coverage:
    scan(
      scheme: "Nestory-Dev",
      code_coverage: true,
      clean: true,
      build_for_testing: true,
      derived_data_path: ".build/DerivedData"
    )
  end

  desc "ğŸ¢ Enterprise Test Suite"
  lane :enterprise_test_suite do
    UI.header "ğŸ¢ Enterprise Test Suite"
    sh("cd #{Dir.pwd}/.. && make test-wiring")
    sh("cd #{Dir.pwd}/.. && make test-performance || true")  # allow perf to be flaky
    sh("cd #{Dir.pwd}/.. && make test-accessibility || true")
  end

  desc "ğŸ“‹ Generate Test Report"
  lane :generate_test_report do
    UI.header "ğŸ“‹ Generate Test Report"
    # If your Makefile assembles HTML reports, prefer that:
    # sh("cd #{Dir.pwd} && make test-report")
    # Otherwise, collate xcresults via test_center if present:
    begin
      collate_html_reports(
        reports: Dir["**/*.xcresult"],
        out_path: "fastlane/output/test-report.html"
      )
    rescue
      UI.message("No xcresult bundles found; skipping collation.")
    end
  end

  desc "ğŸ” Test Center Validation"
  lane :test_center_validation do
    UI.header "ğŸ” Test Center Validation"
    begin
      multi_scan(
        project: "Nestory.xcodeproj",
        scheme: "Nestory-Dev",
        try_count: 1,
        output_directory: "./test_center_results",
        result_bundle: true
      )
      UI.success("âœ… test_center plugin is functional")
    rescue => e
      UI.warning("âš ï¸ test_center issues: #{e.message}")
      UI.message("ğŸ“‹ Falling back to comprehensive UI testsâ€¦")
      sh("cd #{Dir.pwd}/.. && make test-wiring")
    end
  end

end