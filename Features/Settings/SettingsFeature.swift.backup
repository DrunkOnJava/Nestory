//
// Layer: Features
// Module: Settings
// Purpose: Settings Feature TCA Reducer
//
// üèóÔ∏è TCA FEATURE PATTERN: Settings and Configuration Management
// - Manages app settings and preferences using TCA patterns
// - Coordinates between various settings sections and services
// - Handles data management, backup, and export operations
// - FOLLOWS 6-layer architecture: can import UI, Services, Foundation, ComposableArchitecture
//
// üéØ BUSINESS FOCUS: Insurance-focused configuration and data management
// - Theme and appearance settings for optimal viewing
// - Currency settings for accurate valuations
// - Notification settings for warranty/maintenance reminders
// - Import/Export for insurance documentation workflows
// - Cloud backup for data protection against device loss
//
// üìã TCA STANDARDS:
// - State must be Equatable for TCA diffing
// - Actions should be intent-based (updateTheme, not setTheme)
// - Effects return to drive async operations
// - Use @Dependency for service injection
//

import ComposableArchitecture
import SwiftData
import SwiftUI
import Foundation

@Reducer
public struct SettingsFeature: Sendable {
    @ObservableState
    public struct State {
        // üé® APPEARANCE SETTINGS: User interface preferences
        var selectedTheme: AppTheme = .system
        var useSystemAppearance = true

        // üí∞ CURRENCY SETTINGS: Financial calculation preferences
        var selectedCurrency = "USD"
        var showCurrencySymbols = true
        var useDifferentCurrencies = false
        var availableCurrencies: [String] = CurrencyConstants.supportedCurrencies

        // üîî NOTIFICATION SETTINGS: Alert and reminder management
        var notificationsEnabled = true
        var warrantyNotificationsEnabled = true
        var insuranceNotificationsEnabled = true
        var documentNotificationsEnabled = false
        var maintenanceNotificationsEnabled = false
        var notificationAuthorizationStatus: NotificationAuthStatus = .notDetermined

        // üíæ DATA MANAGEMENT: Storage and backup settings
        var localStorageUsed = "0 MB"
        var totalItems = 0
        var cloudBackupEnabled = false
        var cloudBackupStatus: CloudBackupStatus = .notAvailable
        var lastBackupDate: Date? = nil
        var isBackingUp = false

        // üì§ IMPORT/EXPORT SETTINGS: Data portability
        var exportFormat: ExportFormat = .csv
        var includeImages = true
        var includeReceipts = true
        var compressExport = true

        // üîÑ UI STATE: Loading and interaction state
        var isLoading = false
        var showingResetAlert = false
        var showingExportOptions = false
        var showingImportOptions = false
        var showingCloudSettings = false
        @Presents var alert: AlertState<Action.Alert>?
        var exportProgress = 0.0

        // üìä COMPUTED PROPERTIES: Derived settings state
        var hasNotificationPermission: Bool {
            notificationAuthorizationStatus == .authorized
        }

        var canEnableNotifications: Bool {
            notificationAuthorizationStatus != .denied
        }

        var isCloudBackupAvailable: Bool {
            cloudBackupStatus != .notAvailable
        }

        var settingsValidationStatus: SettingsValidationStatus {
            var issues: [SettingsIssue] = []

            if notificationsEnabled, !hasNotificationPermission {
                issues.append(.notificationPermissionRequired)
            }

            if cloudBackupEnabled, !isCloudBackupAvailable {
                issues.append(.cloudBackupUnavailable)
            }

            if selectedCurrency.isEmpty {
                issues.append(.invalidCurrency)
            }

            return SettingsValidationStatus(issues: issues)
        }

        public enum AppTheme: String, CaseIterable, Equatable, Sendable {
            case light = "Light"
            case dark = "Dark"
            case system = "System"
        }

        // Note: Using Foundation.ExportFormat instead of nested enum

        public enum NotificationAuthStatus: Equatable, Sendable {
            case notDetermined
            case denied
            case authorized
        }

        public enum CloudBackupStatus: Equatable, Sendable {
            case notAvailable
            case available
            case syncing
            case error(String)
        }
    }

    public enum Action: Sendable {
        case onAppear
        case loadSettings

        // Theme actions
        case themeChanged(State.AppTheme)
        case systemAppearanceToggled(Bool)

        // Currency actions
        case currencyChanged(String)
        case currencySymbolsToggled(Bool)
        case differentCurrenciesToggled(Bool)

        // Notification actions
        case notificationsToggled(Bool)
        case warrantyNotificationsToggled(Bool)
        case insuranceNotificationsToggled(Bool)
        case documentNotificationsToggled(Bool)
        case maintenanceNotificationsToggled(Bool)
        case requestNotificationPermission
        case notificationPermissionResponse(Bool)
        case notificationStatusLoaded(State.NotificationAuthStatus)

        // Data management actions
        case refreshStorageInfo
        case storageInfoLoaded(String)
        case cloudBackupToggled(Bool)
        case cloudBackupStatusLoaded(State.CloudBackupStatus)
        case performManualBackup
        case backupCompleted(Date)
        case backupFailed(String)

        // Import/Export actions
        case exportFormatChanged(ExportFormat)
        case includeImagesToggled(Bool)
        case includeReceiptsToggled(Bool)
        case compressExportToggled(Bool)
        case showExportOptions
        case hideExportOptions
        case showImportOptions
        case hideImportOptions
        case exportData
        case exportProgress(Double)
        case exportCompleted(URL)
        case exportFailed(String)

        // Danger zone actions
        case showResetAlert
        case confirmReset
        case resetCompleted
        case resetFailed(String)

        // Alert actions
        case alert(PresentationAction<Alert>)

        public enum Alert: Equatable, Sendable {
            case resetConfirmation
            case notificationPermissionDenied
            case exportError(String)
            case backupError(String)
        }
    }

    @Dependency(\.notificationService) var notificationService
    @Dependency(\.cloudBackupService) var cloudBackupService
    @Dependency(\.importExportService) var importExportService
    @Dependency(\.inventoryService) var inventoryService

    public var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case .onAppear:
                return .merge(
                    .send(.loadSettings),
                    .send(.refreshStorageInfo),
                    .run { send in
                        do {
                            try await notificationService.checkAuthorizationStatus()
                            let status = await notificationService.authorizationStatus
                            await send(.notificationStatusLoaded(mapNotificationStatus(status)))
                        } catch {
                            // Handle error gracefully by assuming not determined
                            await send(.notificationStatusLoaded(.notDetermined))
                        }
                    }
                )

            case .loadSettings:
                // Load saved settings from UserDefaults or Keychain
                return .run { send in
                    // This would typically load from persistent storage
                    await send(.currencyChanged(UserDefaults.standard.string(forKey: "selectedCurrency") ?? "USD"))
                }

            case let .themeChanged(theme):
                state.selectedTheme = theme
                state.useSystemAppearance = (theme == .system)
                return .run { _ in
                    // Apply theme change to ThemeManager
                    await applyThemeChange(theme)
                }

            case let .systemAppearanceToggled(enabled):
                state.useSystemAppearance = enabled
                if enabled {
                    state.selectedTheme = .system
                }
                return .none

            case let .currencyChanged(currency):
                state.selectedCurrency = currency
                return .run { _ in
                    UserDefaults.standard.set(currency, forKey: "selectedCurrency")
                }

            case let .currencySymbolsToggled(enabled):
                state.showCurrencySymbols = enabled
                return .none

            case let .differentCurrenciesToggled(enabled):
                state.useDifferentCurrencies = enabled
                return .none

            case let .notificationsToggled(enabled):
                state.notificationsEnabled = enabled
                if enabled, !state.hasNotificationPermission {
                    return .send(.requestNotificationPermission)
                }
                return .none

            case let .warrantyNotificationsToggled(enabled):
                state.warrantyNotificationsEnabled = enabled
                return .none

            case let .insuranceNotificationsToggled(enabled):
                state.insuranceNotificationsEnabled = enabled
                return .none

            case let .documentNotificationsToggled(enabled):
                state.documentNotificationsEnabled = enabled
                return .none

            case let .maintenanceNotificationsToggled(enabled):
                state.maintenanceNotificationsEnabled = enabled
                return .none

            case .requestNotificationPermission:
                return .run { send in
                    do {
                        let granted = try await notificationService.requestAuthorization()
                        await send(.notificationPermissionResponse(granted))
                    } catch {
                        // Handle permission request error by assuming denied
                        await send(.notificationPermissionResponse(false))
                    }
                }

            case let .notificationPermissionResponse(granted):
                state.notificationAuthorizationStatus = granted ? .authorized : .denied
                if !granted {
                    state.notificationsEnabled = false
                    state.alert = AlertState {
                        TextState("Notification Permission Denied")
                    } actions: {
                        ButtonState(action: .notificationPermissionDenied) {
                            TextState("OK")
                        }
                    } message: {
                        TextState("You can enable notifications in Settings app.")
                    }
                }
                return .none

            case let .notificationStatusLoaded(status):
                state.notificationAuthorizationStatus = status
                return .none

            case .refreshStorageInfo:
                return .run { send in
                    let storageInfo = await calculateStorageUsage()
                    await send(.storageInfoLoaded(storageInfo))
                }

            case let .storageInfoLoaded(info):
                state.localStorageUsed = info
                return .none

            case let .cloudBackupToggled(enabled):
                state.cloudBackupEnabled = enabled
                if enabled {
                    return .send(.performManualBackup)
                }
                return .none

            case let .cloudBackupStatusLoaded(status):
                state.cloudBackupStatus = status
                return .none

            case .performManualBackup:
                state.isLoading = true
                return .run { send in
                    do {
                        // Fetch all data needed for backup
                        let items = try await inventoryService.fetchItems()
                        let categories = try await inventoryService.fetchCategories()
                        let rooms = try await inventoryService.fetchRooms()
                        
                        try await cloudBackupService.performBackup(items: items, categories: categories, rooms: rooms)
                        await send(.backupCompleted(Date()))
                    } catch {
                        await send(.backupFailed(error.localizedDescription))
                    }
                }

            case let .backupCompleted(date):
                state.isLoading = false
                state.lastBackupDate = date
                return .none

            case let .backupFailed(error):
                state.isLoading = false
                state.alert = AlertState {
                    TextState("Backup Failed")
                } actions: {
                    ButtonState(action: .backupError(error)) {
                        TextState("Retry")
                    }
                    ButtonState(role: .cancel) {
                        TextState("Cancel")
                    }
                } message: {
                    TextState(error)
                }
                return .none

            case let .exportFormatChanged(format):
                state.exportFormat = format
                return .none

            case let .includeImagesToggled(enabled):
                state.includeImages = enabled
                return .none

            case let .includeReceiptsToggled(enabled):
                state.includeReceipts = enabled
                return .none

            case let .compressExportToggled(enabled):
                state.compressExport = enabled
                return .none

            case .showExportOptions:
                state.showingExportOptions = true
                return .none
            case .hideExportOptions:
                state.showingExportOptions = false
                return .none
            case .showImportOptions:
                state.showingImportOptions = true
                return .none
            case .hideImportOptions:
                state.showingImportOptions = false
                return .none

            case .exportData:
                state.isLoading = true
                state.exportProgress = 0.0
                return .run { [format = state.exportFormat, includeImages = state.includeImages, includeReceipts = state.includeReceipts] send in
                    do {
                        let url = try await importExportService.exportData(
                            format: format,
                            includeImages: includeImages,
                            includeReceipts: includeReceipts,
                            progressCallback: { progress in
                                Task { await send(.exportProgress(progress)) }
                            }
                        )
                        await send(.exportCompleted(url))
                    } catch {
                        await send(.exportFailed(error.localizedDescription))
                    }
                }

            case let .exportProgress(progress):
                state.exportProgress = progress
                return .none

            case let .exportCompleted(url):
                state.isLoading = false
                state.showingExportOptions = false
                state.exportProgress = 0.0
                // Present share sheet or show success message
                return .none

            case let .exportFailed(error):
                state.isLoading = false
                state.exportProgress = 0.0
                state.alert = AlertState {
                    TextState("Export Failed")
                } actions: {
                    ButtonState(action: .exportError(error)) {
                        TextState("OK")
                    }
                } message: {
                    TextState(error)
                }
                return .none

            case .showResetAlert:
                state.showingResetAlert = true
                state.alert = AlertState {
                    TextState("Reset All Data")
                } actions: {
                    ButtonState(role: .destructive, action: .resetConfirmation) {
                        TextState("Reset")
                    }
                    ButtonState(role: .cancel) {
                        TextState("Cancel")
                    }
                } message: {
                    TextState("This will permanently delete all your inventory data. This action cannot be undone.")
                }
                return .none

            case .confirmReset:
                state.isLoading = true
                return .run { send in
                    do {
                        try await performDataReset()
                        await send(.resetCompleted)
                    } catch {
                        await send(.resetFailed(error.localizedDescription))
                    }
                }

            case .resetCompleted:
                state.isLoading = false
                state.showingResetAlert = false
                return .none

            case let .resetFailed(error):
                state.isLoading = false
                state.alert = AlertState {
                    TextState("Reset Failed")
                } actions: {
                    ButtonState(role: .cancel) {
                        TextState("OK")
                    }
                } message: {
                    TextState(error)
                }
                return .none

            case .alert(.presented(.resetConfirmation)):
                return .send(.confirmReset)
                
            case .alert(.presented(.notificationPermissionDenied)):
                return .none
                
            case .alert(.presented(.exportError)):
                return .none
                
            case .alert(.presented(.backupError)):
                return .send(.performManualBackup)
                
            case .alert(.dismiss):
                return .none
            }
        }
        .ifLet(\.$alert, action: \.alert)
    }
}

// MARK: - Equatable Conformance

extension SettingsFeature.State: Equatable {
    public static func == (lhs: SettingsFeature.State, rhs: SettingsFeature.State) -> Bool {
        return lhs.selectedTheme == rhs.selectedTheme &&
               lhs.useSystemAppearance == rhs.useSystemAppearance &&
               lhs.selectedCurrency == rhs.selectedCurrency &&
               lhs.showCurrencySymbols == rhs.showCurrencySymbols &&
               lhs.useDifferentCurrencies == rhs.useDifferentCurrencies &&
               lhs.availableCurrencies == rhs.availableCurrencies &&
               lhs.notificationsEnabled == rhs.notificationsEnabled &&
               lhs.warrantyNotificationsEnabled == rhs.warrantyNotificationsEnabled &&
               lhs.insuranceNotificationsEnabled == rhs.insuranceNotificationsEnabled &&
               lhs.documentNotificationsEnabled == rhs.documentNotificationsEnabled &&
               lhs.maintenanceNotificationsEnabled == rhs.maintenanceNotificationsEnabled &&
               lhs.notificationAuthorizationStatus == rhs.notificationAuthorizationStatus &&
               lhs.localStorageUsed == rhs.localStorageUsed &&
               lhs.cloudBackupEnabled == rhs.cloudBackupEnabled &&
               lhs.cloudBackupStatus == rhs.cloudBackupStatus &&
               lhs.lastBackupDate == rhs.lastBackupDate &&
               lhs.exportFormat == rhs.exportFormat &&
               lhs.includeImages == rhs.includeImages &&
               lhs.includeReceipts == rhs.includeReceipts &&
               lhs.compressExport == rhs.compressExport &&
               lhs.isLoading == rhs.isLoading &&
               lhs.showingResetAlert == rhs.showingResetAlert &&
               lhs.showingExportOptions == rhs.showingExportOptions &&
               lhs.showingCloudSettings == rhs.showingCloudSettings &&
               lhs.exportProgress == rhs.exportProgress
        // Note: alert is excluded from comparison as @Presents creates PresentationState
        // which doesn't participate in meaningful state equality for TCA diffing
    }
}

// MARK: - Supporting Types

struct SettingsValidationStatus: Equatable {
    let issues: [SettingsIssue]

    var isValid: Bool { issues.isEmpty }
    var hasWarnings: Bool { !issues.filter { $0.severity == .warning }.isEmpty }
    var hasErrors: Bool { !issues.filter { $0.severity == .error }.isEmpty }
}

struct SettingsIssue: Equatable {
    let type: IssueType
    let severity: Severity
    let message: String

    enum IssueType: Equatable {
        case notificationPermissionRequired
        case cloudBackupUnavailable
        case invalidCurrency
    }

    enum Severity: Equatable {
        case warning
        case error
    }
}

extension SettingsIssue {
    static let notificationPermissionRequired = SettingsIssue(
        type: .notificationPermissionRequired,
        severity: .warning,
        message: "Notification permission required for alerts"
    )

    static let cloudBackupUnavailable = SettingsIssue(
        type: .cloudBackupUnavailable,
        severity: .error,
        message: "iCloud backup is not available"
    )

    static let invalidCurrency = SettingsIssue(
        type: .invalidCurrency,
        severity: .error,
        message: "Invalid currency selection"
    )
}

// MARK: - Constants

private enum CurrencyConstants {
    static let supportedCurrencies = [
        "USD", "EUR", "GBP", "CAD", "AUD", "JPY", "CHF", "CNY", "INR", "KRW",
    ]
}

// MARK: - Helper Functions

private func mapNotificationStatus(_ status: UNAuthorizationStatus) -> SettingsFeature.State.NotificationAuthStatus {
    switch status {
    case .notDetermined:
        return .notDetermined
    case .denied:
        return .denied
    case .authorized, .provisional, .ephemeral:
        return .authorized
    @unknown default:
        return .notDetermined
    }
}

private func applyThemeChange(_: SettingsFeature.State.AppTheme) async {
    // Integration with ThemeManager would go here
    await MainActor.run {
        // ThemeManager.shared.setTheme(theme)
    }
}

private func calculateStorageUsage() async -> String {
    // Calculate actual storage usage
    let bytes = 1024 * 1024 * 5 // Placeholder: 5MB
    let formatter = ByteCountFormatter()
    formatter.countStyle = .file
    return formatter.string(fromByteCount: Int64(bytes))
}

private func performDataReset() async throws {
    // Implementation would clear all CoreData/SwiftData
    // This is a destructive operation that requires careful implementation
    throw NSError(domain: "SettingsError", code: 1, userInfo: [NSLocalizedDescriptionKey: "Reset not implemented"])
}

// MARK: - TCA Integration Notes

//
// üîó SERVICE INTEGRATION: Uses multiple protocol-based services
// - NotificationService: Permission management and scheduling
// - CloudBackupService: iCloud backup and sync operations
// - ImportExportService: Data export and sharing capabilities
// - All services injected via @Dependency for testability
//
// üéØ STATE MANAGEMENT: Comprehensive settings coordination
// - Real-time validation of settings combinations
// - Async operations for permission requests and data operations
// - Error handling for all potential failure scenarios
// - Loading states for smooth user experience
//
