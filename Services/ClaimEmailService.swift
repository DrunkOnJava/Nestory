//
// Layer: Services
// Module: ClaimEmail
// Purpose: Email composition and sending service for insurance claim submissions
//

import Foundation
import MessageUI
import SwiftUI

// MARK: - Email Service

@MainActor
public final class ClaimEmailService: NSObject, ObservableObject {
    @Published public var isComposingEmail = false
    @Published public var emailError: EmailError?

    override public init() {
        super.init()
    }

    // MARK: - Email Composition

    public func composeClaimEmail(
        claim: ClaimSubmission,
        recipientEmail: String,
        fileURL: URL
    ) -> ClaimEmail {
        let subject = generateEmailSubject(for: claim)
        let body = generateEmailBody(for: claim)

        return ClaimEmail(
            to: recipientEmail,
            subject: subject,
            body: body,
            attachments: [EmailAttachment(fileURL: fileURL, mimeType: getMimeType(for: fileURL))]
        )
    }

    // MARK: - Email Templates

    private func generateEmailSubject(for claim: ClaimSubmission) -> String {
        var subject = "Insurance Claim Submission"

        if let claimNumber = claim.claimNumber {
            subject += " - Claim #\(claimNumber)"
        }

        if let policyNumber = claim.policyNumber {
            subject += " - Policy #\(policyNumber)"
        }

        subject += " - \(claim.claimType.rawValue)"

        return subject
    }

    private func generateEmailBody(for claim: ClaimSubmission) -> String {
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .medium
        dateFormatter.timeStyle = .none

        var body = """
        Dear Claims Representative,

        I am submitting an insurance claim for your review and processing.

        CLAIM INFORMATION:
        - Claim Type: \(claim.claimType.rawValue)
        """

        if let policyNumber = claim.policyNumber {
            body += "\n- Policy Number: \(policyNumber)"
        }

        if let incidentDate = claim.incidentDate {
            body += "\n- Incident Date: \(dateFormatter.string(from: incidentDate))"
        }

        body += """

        - Total Items: \(claim.totalItemCount)
        - Total Claimed Value: $\(claim.totalClaimedValue)
        - Insurance Company: \(claim.insuranceCompany)

        SUBMISSION DETAILS:
        This email includes a comprehensive inventory documentation package with the following:

        ✓ Detailed item inventory with descriptions
        ✓ Purchase prices and acquisition dates
        ✓ Item photographs (where available)
        ✓ Receipt documentation (where available)
        ✓ Serial numbers and model information

        The attached file contains all necessary documentation to support this claim submission. All information has been compiled from my digital home inventory system and represents accurate records of the damaged/lost items.

        NEXT STEPS:
        Please confirm receipt of this submission and provide:
        1. Claim reference/confirmation number
        2. Expected timeline for claim processing
        3. Contact information for my assigned claims adjuster
        4. Any additional documentation requirements

        I am available to provide any additional information or documentation as needed. Please contact me at your earliest convenience to discuss this claim.

        Thank you for your prompt attention to this matter.

        Respectfully,
        [Policyholder Name]
        [Contact Information]

        ---
        This claim submission was generated by Nestory Home Inventory App
        Submission ID: \(claim.id.uuidString.prefix(8))
        Generated: \(dateFormatter.string(from: claim.createdAt))
        """

        return body
    }

    // MARK: - Email Validation

    public func validateEmailRequirements(
        email: ClaimEmail,
        requirements: EmailValidationRequirements = .standard
    ) throws {
        var validationErrors: [String] = []

        // Validate email address
        if !isValidEmail(email.to) {
            validationErrors.append("Invalid recipient email address")
        }

        // Validate subject
        if email.subject.count > requirements.maxSubjectLength {
            validationErrors.append("Email subject too long (max \(requirements.maxSubjectLength) characters)")
        }

        // Validate body
        if email.body.count > requirements.maxBodyLength {
            validationErrors.append("Email body too long (max \(requirements.maxBodyLength) characters)")
        }

        // Validate attachments
        let totalAttachmentSize = email.attachments.reduce(0) { $0 + $1.fileSize }
        if totalAttachmentSize > requirements.maxAttachmentSize {
            validationErrors.append("Total attachment size exceeds limit (\(formatBytes(requirements.maxAttachmentSize)))")
        }

        if email.attachments.count > requirements.maxAttachments {
            validationErrors.append("Too many attachments (max \(requirements.maxAttachments))")
        }

        if !validationErrors.isEmpty {
            throw EmailError.validationFailed(validationErrors)
        }
    }

    // MARK: - Utility Methods

    private func isValidEmail(_ email: String) -> Bool {
        let emailRegEx = "[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,64}"
        let emailPred = NSPredicate(format: "SELF MATCHES %@", emailRegEx)
        return emailPred.evaluate(with: email)
    }

    private func getMimeType(for fileURL: URL) -> String {
        let pathExtension = fileURL.pathExtension.lowercased()

        switch pathExtension {
        case "pdf": return "application/pdf"
        case "xlsx", "xls": return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
        case "xml": return "application/xml"
        case "json": return "application/json"
        case "zip": return "application/zip"
        case "jpg", "jpeg": return "image/jpeg"
        case "png": return "image/png"
        default: return "application/octet-stream"
        }
    }

    private func formatBytes(_ bytes: Int) -> String {
        let formatter = ByteCountFormatter()
        formatter.countStyle = .file
        return formatter.string(fromByteCount: Int64(bytes))
    }
}

// MARK: - Data Models

public struct ClaimEmail {
    public let to: String
    public let subject: String
    public let body: String
    public let attachments: [EmailAttachment]

    public init(to: String, subject: String, body: String, attachments: [EmailAttachment] = []) {
        self.to = to
        self.subject = subject
        self.body = body
        self.attachments = attachments
    }
}

public struct EmailAttachment {
    public let fileURL: URL
    public let fileName: String
    public let mimeType: String
    public let fileSize: Int

    public init(fileURL: URL, mimeType: String) {
        self.fileURL = fileURL
        self.fileName = fileURL.lastPathComponent
        self.mimeType = mimeType

        // Get file size
        if let attributes = try? FileManager.default.attributesOfItem(atPath: fileURL.path),
           let size = attributes[.size] as? Int
        {
            self.fileSize = size
        } else {
            self.fileSize = 0
        }
    }
}

public struct EmailValidationRequirements: Sendable {
    public let maxSubjectLength: Int
    public let maxBodyLength: Int
    public let maxAttachmentSize: Int // bytes
    public let maxAttachments: Int
    public let allowedMimeTypes: Set<String>

    public static let standard = EmailValidationRequirements(
        maxSubjectLength: 200,
        maxBodyLength: 10000,
        maxAttachmentSize: 25_000_000, // 25MB
        maxAttachments: 5,
        allowedMimeTypes: [
            "application/pdf",
            "application/zip",
            "application/xml",
            "application/json",
            "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
            "image/jpeg",
            "image/png",
        ]
    )

    public init(
        maxSubjectLength: Int,
        maxBodyLength: Int,
        maxAttachmentSize: Int,
        maxAttachments: Int,
        allowedMimeTypes: Set<String>
    ) {
        self.maxSubjectLength = maxSubjectLength
        self.maxBodyLength = maxBodyLength
        self.maxAttachmentSize = maxAttachmentSize
        self.maxAttachments = maxAttachments
        self.allowedMimeTypes = allowedMimeTypes
    }
}

// MARK: - Email Error Types

public enum EmailError: Error, LocalizedError {
    case validationFailed([String])
    case composerNotAvailable
    case sendingFailed(String)
    case attachmentError(String)

    public var errorDescription: String? {
        switch self {
        case let .validationFailed(errors):
            "Email validation failed: \(errors.joined(separator: ", "))"
        case .composerNotAvailable:
            "Email composer is not available on this device"
        case let .sendingFailed(reason):
            "Failed to send email: \(reason)"
        case let .attachmentError(reason):
            "Attachment error: \(reason)"
        }
    }
}

// MARK: - Mail Composer Coordinator

public struct MailComposerView: UIViewControllerRepresentable {
    let email: ClaimEmail
    let onResult: (Result<Void, EmailError>) -> Void

    public init(email: ClaimEmail, onResult: @escaping (Result<Void, EmailError>) -> Void) {
        self.email = email
        self.onResult = onResult
    }

    public func makeUIViewController(context: Context) -> MFMailComposeViewController {
        let composer = MFMailComposeViewController()
        composer.mailComposeDelegate = context.coordinator

        // Configure email
        composer.setToRecipients([email.to])
        composer.setSubject(email.subject)
        composer.setMessageBody(email.body, isHTML: false)

        // Add attachments
        for attachment in email.attachments {
            if let data = try? Data(contentsOf: attachment.fileURL) {
                composer.addAttachmentData(
                    data,
                    mimeType: attachment.mimeType,
                    fileName: attachment.fileName
                )
            }
        }

        return composer
    }

    public func updateUIViewController(_: MFMailComposeViewController, context _: Context) {
        // No updates needed
    }

    public func makeCoordinator() -> Coordinator {
        Coordinator(onResult: onResult)
    }

    public class Coordinator: NSObject, @preconcurrency MFMailComposeViewControllerDelegate {
        let onResult: (Result<Void, EmailError>) -> Void

        init(onResult: @escaping (Result<Void, EmailError>) -> Void) {
            self.onResult = onResult
        }

        @MainActor public func mailComposeController(
            _ controller: MFMailComposeViewController,
            didFinishWith result: MFMailComposeResult,
            error: (any Error)?
        ) {
            controller.dismiss(animated: true) {
                if let error {
                    self.onResult(.failure(.sendingFailed(error.localizedDescription)))
                } else {
                    switch result {
                    case .sent:
                        self.onResult(.success(()))
                    case .cancelled:
                        self.onResult(.failure(.sendingFailed("Email cancelled by user")))
                    case .failed:
                        self.onResult(.failure(.sendingFailed("Email sending failed")))
                    case .saved:
                        self.onResult(.success(()))
                    @unknown default:
                        self.onResult(.failure(.sendingFailed("Unknown result")))
                    }
                }
            }
        }
    }
}
